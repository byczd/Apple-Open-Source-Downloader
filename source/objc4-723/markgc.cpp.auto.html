<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>markgc.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">markgc.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="markgc.cpp">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2007-2009 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdbool.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;limits.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mman.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;os/overflow.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/fat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/arch.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/loader.h&gt;</span>

<span class="enscript-comment">// Some OS X SDKs don't define these.
</span>#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">CPU_TYPE_ARM</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CPU_TYPE_ARM</span>            ((cpu_type_t) 12)
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">CPU_ARCH_ABI64</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CPU_ARCH_ABI64</span>  0x01000000              <span class="enscript-comment">/* 64 bit ABI */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">CPU_TYPE_ARM64</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CPU_TYPE_ARM64</span>          (CPU_TYPE_ARM | CPU_ARCH_ABI64)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// File abstraction taken from ld64/FileAbstraction.hpp 
</span><span class="enscript-comment">// and ld64/MachOFileAbstraction.hpp.
</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__OPTIMIZE__</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INLINE</span>	__attribute__((always_inline))
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INLINE</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">//
</span><span class="enscript-comment">// This abstraction layer is for use with file formats that have 64-bit/32-bit and Big-Endian/Little-Endian variants
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// For example: to make a utility that handles 32-bit little enidan files use:  Pointer32&lt;LittleEndian&gt;
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//		get16()			read a 16-bit number from an E endian struct
</span><span class="enscript-comment">//		set16()			write a 16-bit number to an E endian struct
</span><span class="enscript-comment">//		get32()			read a 32-bit number from an E endian struct
</span><span class="enscript-comment">//		set32()			write a 32-bit number to an E endian struct
</span><span class="enscript-comment">//		get64()			read a 64-bit number from an E endian struct
</span><span class="enscript-comment">//		set64()			write a 64-bit number to an E endian struct
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//		getBits()		read a bit field from an E endian struct (bitCount=number of bits in field, firstBit=bit index of field)
</span><span class="enscript-comment">//		setBits()		write a bit field to an E endian struct (bitCount=number of bits in field, firstBit=bit index of field)
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//		getBitsRaw()	read a bit field from a struct with native endianness
</span><span class="enscript-comment">//		setBitsRaw()	write a bit field from a struct with native endianness
</span><span class="enscript-comment">//
</span>
<span class="enscript-type">class</span> BigEndian
{
<span class="enscript-type">public</span>:
	<span class="enscript-type">static</span> uint16_t	get16(<span class="enscript-type">const</span> uint16_t&amp; from)				INLINE { <span class="enscript-keyword">return</span> OSReadBigInt16(&amp;from, 0); }
	<span class="enscript-type">static</span> <span class="enscript-type">void</span>		set16(uint16_t&amp; into, uint16_t value)	INLINE { OSWriteBigInt16(&amp;into, 0, value); }
	
	<span class="enscript-type">static</span> uint32_t	get32(<span class="enscript-type">const</span> uint32_t&amp; from)				INLINE { <span class="enscript-keyword">return</span> OSReadBigInt32(&amp;from, 0); }
	<span class="enscript-type">static</span> <span class="enscript-type">void</span>		set32(uint32_t&amp; into, uint32_t value)	INLINE { OSWriteBigInt32(&amp;into, 0, value); }
	
	<span class="enscript-type">static</span> uint64_t get64(<span class="enscript-type">const</span> uint64_t&amp; from)				INLINE { <span class="enscript-keyword">return</span> OSReadBigInt64(&amp;from, 0); }
	<span class="enscript-type">static</span> <span class="enscript-type">void</span>		set64(uint64_t&amp; into, uint64_t value)	INLINE { OSWriteBigInt64(&amp;into, 0, value); }
	
	<span class="enscript-type">static</span> uint32_t	getBits(<span class="enscript-type">const</span> uint32_t&amp; from, 
						uint8_t firstBit, uint8_t bitCount)	INLINE { <span class="enscript-keyword">return</span> getBitsRaw(get32(from), firstBit, bitCount); }
	<span class="enscript-type">static</span> <span class="enscript-type">void</span>		setBits(uint32_t&amp; into, uint32_t value,
						uint8_t firstBit, uint8_t bitCount)	INLINE { uint32_t temp = get32(into); setBitsRaw(temp, value, firstBit, bitCount); set32(into, temp); }

	<span class="enscript-type">static</span> uint32_t	getBitsRaw(<span class="enscript-type">const</span> uint32_t&amp; from, 
						uint8_t firstBit, uint8_t bitCount)	INLINE { <span class="enscript-keyword">return</span> ((from &gt;&gt; (32-firstBit-bitCount)) &amp; ((1&lt;&lt;bitCount)-1)); }
	<span class="enscript-type">static</span> <span class="enscript-type">void</span>		setBitsRaw(uint32_t&amp; into, uint32_t value,
						uint8_t firstBit, uint8_t bitCount)	INLINE { uint32_t temp = into; 
																							<span class="enscript-type">const</span> uint32_t mask = ((1&lt;&lt;bitCount)-1); 
																							temp &amp;= ~(mask &lt;&lt; (32-firstBit-bitCount)); 
																							temp |= ((value &amp; mask) &lt;&lt; (32-firstBit-bitCount)); 
																							into = temp; }
	<span class="enscript-type">enum</span> { little_endian = 0 };
};


<span class="enscript-type">class</span> LittleEndian
{
<span class="enscript-type">public</span>:
	<span class="enscript-type">static</span> uint16_t	get16(<span class="enscript-type">const</span> uint16_t&amp; from)				INLINE { <span class="enscript-keyword">return</span> OSReadLittleInt16(&amp;from, 0); }
	<span class="enscript-type">static</span> <span class="enscript-type">void</span>		set16(uint16_t&amp; into, uint16_t value)	INLINE { OSWriteLittleInt16(&amp;into, 0, value); }
	
	<span class="enscript-type">static</span> uint32_t	get32(<span class="enscript-type">const</span> uint32_t&amp; from)				INLINE { <span class="enscript-keyword">return</span> OSReadLittleInt32(&amp;from, 0); }
	<span class="enscript-type">static</span> <span class="enscript-type">void</span>		set32(uint32_t&amp; into, uint32_t value)	INLINE { OSWriteLittleInt32(&amp;into, 0, value); }
	
	<span class="enscript-type">static</span> uint64_t get64(<span class="enscript-type">const</span> uint64_t&amp; from)				INLINE { <span class="enscript-keyword">return</span> OSReadLittleInt64(&amp;from, 0); }
	<span class="enscript-type">static</span> <span class="enscript-type">void</span>		set64(uint64_t&amp; into, uint64_t value)	INLINE { OSWriteLittleInt64(&amp;into, 0, value); }

	<span class="enscript-type">static</span> uint32_t	getBits(<span class="enscript-type">const</span> uint32_t&amp; from,
						uint8_t firstBit, uint8_t bitCount)	INLINE { <span class="enscript-keyword">return</span> getBitsRaw(get32(from), firstBit, bitCount); }
	<span class="enscript-type">static</span> <span class="enscript-type">void</span>		setBits(uint32_t&amp; into, uint32_t value,
						uint8_t firstBit, uint8_t bitCount)	INLINE { uint32_t temp = get32(into); setBitsRaw(temp, value, firstBit, bitCount); set32(into, temp); }

	<span class="enscript-type">static</span> uint32_t	getBitsRaw(<span class="enscript-type">const</span> uint32_t&amp; from,
						uint8_t firstBit, uint8_t bitCount)	INLINE { <span class="enscript-keyword">return</span> ((from &gt;&gt; firstBit) &amp; ((1&lt;&lt;bitCount)-1)); }
	<span class="enscript-type">static</span> <span class="enscript-type">void</span>		setBitsRaw(uint32_t&amp; into, uint32_t value,
						uint8_t firstBit, uint8_t bitCount)	INLINE {  uint32_t temp = into; 
																							<span class="enscript-type">const</span> uint32_t mask = ((1&lt;&lt;bitCount)-1); 
																							temp &amp;= ~(mask &lt;&lt; firstBit); 
																							temp |= ((value &amp; mask) &lt;&lt; firstBit); 
																							into = temp; }
	<span class="enscript-type">enum</span> { little_endian = 1 };
};

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__BIG_ENDIAN__</span>
<span class="enscript-type">typedef</span> BigEndian CurrentEndian;
<span class="enscript-type">typedef</span> LittleEndian OtherEndian;
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">__LITTLE_ENDIAN__</span>
<span class="enscript-type">typedef</span> LittleEndian CurrentEndian;
<span class="enscript-type">typedef</span> BigEndian OtherEndian;
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">unknown</span> <span class="enscript-variable-name">endianness</span>
#<span class="enscript-reference">endif</span>


<span class="enscript-type">template</span> &lt;typename _E&gt;
<span class="enscript-type">class</span> Pointer32
{
<span class="enscript-type">public</span>:
	<span class="enscript-type">typedef</span> uint32_t	uint_t;
	<span class="enscript-type">typedef</span> int32_t		sint_t;
	<span class="enscript-type">typedef</span> _E			E;
	
	<span class="enscript-type">static</span> uint64_t	getP(<span class="enscript-type">const</span> uint_t&amp; from)				INLINE { <span class="enscript-keyword">return</span> _E::get32(from); }
	<span class="enscript-type">static</span> <span class="enscript-type">void</span>		setP(uint_t&amp; into, uint64_t value)		INLINE { _E::set32(into, value); }
};


<span class="enscript-type">template</span> &lt;typename _E&gt;
<span class="enscript-type">class</span> Pointer64
{
<span class="enscript-type">public</span>:
	<span class="enscript-type">typedef</span> uint64_t	uint_t;
	<span class="enscript-type">typedef</span> int64_t		sint_t;
	<span class="enscript-type">typedef</span> _E			E;
	
	<span class="enscript-type">static</span> uint64_t	getP(<span class="enscript-type">const</span> uint_t&amp; from)				INLINE { <span class="enscript-keyword">return</span> _E::get64(from); }
	<span class="enscript-type">static</span> <span class="enscript-type">void</span>		setP(uint_t&amp; into, uint64_t value)		INLINE { _E::set64(into, value); }
};


<span class="enscript-comment">//
</span><span class="enscript-comment">// mach-o file header
</span><span class="enscript-comment">//
</span><span class="enscript-type">template</span> &lt;typename P&gt; <span class="enscript-type">struct</span> macho_header_content {};
<span class="enscript-type">template</span> &lt;&gt; <span class="enscript-type">struct</span> macho_header_content&lt;Pointer32&lt;BigEndian&gt; &gt;    { mach_header		fields; };
<span class="enscript-type">template</span> &lt;&gt; <span class="enscript-type">struct</span> macho_header_content&lt;Pointer64&lt;BigEndian&gt; &gt;	  { mach_header_64	fields; };
<span class="enscript-type">template</span> &lt;&gt; <span class="enscript-type">struct</span> macho_header_content&lt;Pointer32&lt;LittleEndian&gt; &gt; { mach_header		fields; };
<span class="enscript-type">template</span> &lt;&gt; <span class="enscript-type">struct</span> macho_header_content&lt;Pointer64&lt;LittleEndian&gt; &gt; { mach_header_64	fields; };

<span class="enscript-type">template</span> &lt;typename P&gt;
<span class="enscript-type">class</span> macho_header {
<span class="enscript-type">public</span>:
	uint32_t		magic() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> E::get32(header.fields.magic); }
	<span class="enscript-type">void</span>			set_magic(uint32_t value)		INLINE { E::set32(header.fields.magic, value); }

	uint32_t		cputype() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> E::get32(header.fields.cputype); }
	<span class="enscript-type">void</span>			set_cputype(uint32_t value)		INLINE { E::set32((uint32_t&amp;)header.fields.cputype, value); }

	uint32_t		cpusubtype() <span class="enscript-type">const</span>				INLINE { <span class="enscript-keyword">return</span> E::get32(header.fields.cpusubtype); }
	<span class="enscript-type">void</span>			set_cpusubtype(uint32_t value)	INLINE { E::set32((uint32_t&amp;)header.fields.cpusubtype, value); }

	uint32_t		filetype() <span class="enscript-type">const</span>				INLINE { <span class="enscript-keyword">return</span> E::get32(header.fields.filetype); }
	<span class="enscript-type">void</span>			set_filetype(uint32_t value)	INLINE { E::set32(header.fields.filetype, value); }

	uint32_t		ncmds() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> E::get32(header.fields.ncmds); }
	<span class="enscript-type">void</span>			set_ncmds(uint32_t value)		INLINE { E::set32(header.fields.ncmds, value); }

	uint32_t		sizeofcmds() <span class="enscript-type">const</span>				INLINE { <span class="enscript-keyword">return</span> E::get32(header.fields.sizeofcmds); }
	<span class="enscript-type">void</span>			set_sizeofcmds(uint32_t value)	INLINE { E::set32(header.fields.sizeofcmds, value); }

	uint32_t		flags() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> E::get32(header.fields.flags); }
	<span class="enscript-type">void</span>			set_flags(uint32_t value)		INLINE { E::set32(header.fields.flags, value); }

	uint32_t		reserved() <span class="enscript-type">const</span>				INLINE { <span class="enscript-keyword">return</span> E::get32(header.fields.reserved); }
	<span class="enscript-type">void</span>			set_reserved(uint32_t value)	INLINE { E::set32(header.fields.reserved, value); }

	<span class="enscript-type">typedef</span> typename P::E		E;
<span class="enscript-type">private</span>:
	macho_header_content&lt;P&gt;	header;
};


<span class="enscript-comment">//
</span><span class="enscript-comment">// mach-o load command
</span><span class="enscript-comment">//
</span><span class="enscript-type">template</span> &lt;typename P&gt;
<span class="enscript-type">class</span> macho_load_command {
<span class="enscript-type">public</span>:
	uint32_t		cmd() <span class="enscript-type">const</span>						INLINE { <span class="enscript-keyword">return</span> E::get32(command.cmd); }
	<span class="enscript-type">void</span>			set_cmd(uint32_t value)			INLINE { E::set32(command.cmd, value); }

	uint32_t		cmdsize() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> E::get32(command.cmdsize); }
	<span class="enscript-type">void</span>			set_cmdsize(uint32_t value)		INLINE { E::set32(command.cmdsize, value); }

	<span class="enscript-type">typedef</span> typename P::E		E;
<span class="enscript-type">private</span>:
	load_command	command;
};




<span class="enscript-comment">//
</span><span class="enscript-comment">// mach-o segment load command
</span><span class="enscript-comment">//
</span><span class="enscript-type">template</span> &lt;typename P&gt; <span class="enscript-type">struct</span> macho_segment_content {};
<span class="enscript-type">template</span> &lt;&gt; <span class="enscript-type">struct</span> macho_segment_content&lt;Pointer32&lt;BigEndian&gt; &gt;    { segment_command	fields; <span class="enscript-type">enum</span> { CMD = LC_SEGMENT		}; };
<span class="enscript-type">template</span> &lt;&gt; <span class="enscript-type">struct</span> macho_segment_content&lt;Pointer64&lt;BigEndian&gt; &gt;	   { segment_command_64	fields; <span class="enscript-type">enum</span> { CMD = LC_SEGMENT_64	}; };
<span class="enscript-type">template</span> &lt;&gt; <span class="enscript-type">struct</span> macho_segment_content&lt;Pointer32&lt;LittleEndian&gt; &gt; { segment_command	fields; <span class="enscript-type">enum</span> { CMD = LC_SEGMENT		}; };
<span class="enscript-type">template</span> &lt;&gt; <span class="enscript-type">struct</span> macho_segment_content&lt;Pointer64&lt;LittleEndian&gt; &gt; { segment_command_64	fields; <span class="enscript-type">enum</span> { CMD = LC_SEGMENT_64	}; };

<span class="enscript-type">template</span> &lt;typename P&gt;
<span class="enscript-type">class</span> macho_segment_command {
<span class="enscript-type">public</span>:
	uint32_t		cmd() <span class="enscript-type">const</span>						INLINE { <span class="enscript-keyword">return</span> E::get32(segment.fields.cmd); }
	<span class="enscript-type">void</span>			set_cmd(uint32_t value)			INLINE { E::set32(segment.fields.cmd, value); }

	uint32_t		cmdsize() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> E::get32(segment.fields.cmdsize); }
	<span class="enscript-type">void</span>			set_cmdsize(uint32_t value)		INLINE { E::set32(segment.fields.cmdsize, value); }

	<span class="enscript-type">const</span> <span class="enscript-type">char</span>*		segname() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> segment.fields.segname; }
	<span class="enscript-type">void</span>			set_segname(<span class="enscript-type">const</span> <span class="enscript-type">char</span>* value)	INLINE { strncpy(segment.fields.segname, value, 16); }
	
	uint64_t		vmaddr() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> P::getP(segment.fields.vmaddr); }
	<span class="enscript-type">void</span>			set_vmaddr(uint64_t value)		INLINE { P::setP(segment.fields.vmaddr, value); }

	uint64_t		vmsize() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> P::getP(segment.fields.vmsize); }
	<span class="enscript-type">void</span>			set_vmsize(uint64_t value)		INLINE { P::setP(segment.fields.vmsize, value); }

	uint64_t		fileoff() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> P::getP(segment.fields.fileoff); }
	<span class="enscript-type">void</span>			set_fileoff(uint64_t value)		INLINE { P::setP(segment.fields.fileoff, value); }

	uint64_t		filesize() <span class="enscript-type">const</span>				INLINE { <span class="enscript-keyword">return</span> P::getP(segment.fields.filesize); }
	<span class="enscript-type">void</span>			set_filesize(uint64_t value)	INLINE { P::setP(segment.fields.filesize, value); }

	uint32_t		maxprot() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> E::get32(segment.fields.maxprot); }
	<span class="enscript-type">void</span>			set_maxprot(uint32_t value)		INLINE { E::set32((uint32_t&amp;)segment.fields.maxprot, value); }

	uint32_t		initprot() <span class="enscript-type">const</span>				INLINE { <span class="enscript-keyword">return</span> E::get32(segment.fields.initprot); }
	<span class="enscript-type">void</span>			set_initprot(uint32_t value)	INLINE { E::set32((uint32_t&amp;)segment.fields.initprot, value); }

	uint32_t		nsects() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> E::get32(segment.fields.nsects); }
	<span class="enscript-type">void</span>			set_nsects(uint32_t value)		INLINE { E::set32(segment.fields.nsects, value); }

	uint32_t		flags() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> E::get32(segment.fields.flags); }
	<span class="enscript-type">void</span>			set_flags(uint32_t value)		INLINE { E::set32(segment.fields.flags, value); }

	<span class="enscript-type">enum</span> {
		CMD = macho_segment_content&lt;P&gt;::CMD
	};

	<span class="enscript-type">typedef</span> typename P::E		E;
<span class="enscript-type">private</span>:
	macho_segment_content&lt;P&gt;	segment;
};


<span class="enscript-comment">//
</span><span class="enscript-comment">// mach-o section 
</span><span class="enscript-comment">//
</span><span class="enscript-type">template</span> &lt;typename P&gt; <span class="enscript-type">struct</span> macho_section_content {};
<span class="enscript-type">template</span> &lt;&gt; <span class="enscript-type">struct</span> macho_section_content&lt;Pointer32&lt;BigEndian&gt; &gt;    { section	fields; };
<span class="enscript-type">template</span> &lt;&gt; <span class="enscript-type">struct</span> macho_section_content&lt;Pointer64&lt;BigEndian&gt; &gt;	   { section_64	fields; };
<span class="enscript-type">template</span> &lt;&gt; <span class="enscript-type">struct</span> macho_section_content&lt;Pointer32&lt;LittleEndian&gt; &gt; { section	fields; };
<span class="enscript-type">template</span> &lt;&gt; <span class="enscript-type">struct</span> macho_section_content&lt;Pointer64&lt;LittleEndian&gt; &gt; { section_64	fields; };

<span class="enscript-type">template</span> &lt;typename P&gt;
<span class="enscript-type">class</span> macho_section {
<span class="enscript-type">public</span>:
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>*		sectname() <span class="enscript-type">const</span>				INLINE { <span class="enscript-keyword">return</span> section.fields.sectname; }
	<span class="enscript-type">void</span>			set_sectname(<span class="enscript-type">const</span> <span class="enscript-type">char</span>* value)	INLINE { strncpy(section.fields.sectname, value, 16); }
	
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>*		segname() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> section.fields.segname; }
	<span class="enscript-type">void</span>			set_segname(<span class="enscript-type">const</span> <span class="enscript-type">char</span>* value)	INLINE { strncpy(section.fields.segname, value, 16); }
	
	uint64_t		addr() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> P::getP(section.fields.addr); }
	<span class="enscript-type">void</span>			set_addr(uint64_t value)		INLINE { P::setP(section.fields.addr, value); }

	uint64_t		size() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> P::getP(section.fields.size); }
	<span class="enscript-type">void</span>			set_size(uint64_t value)		INLINE { P::setP(section.fields.size, value); }

	uint32_t		offset() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> E::get32(section.fields.offset); }
	<span class="enscript-type">void</span>			set_offset(uint32_t value)		INLINE { E::set32(section.fields.offset, value); }

	uint32_t		align() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> E::get32(section.fields.align); }
	<span class="enscript-type">void</span>			set_align(uint32_t value)		INLINE { E::set32(section.fields.align, value); }

	uint32_t		reloff() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> E::get32(section.fields.reloff); }
	<span class="enscript-type">void</span>			set_reloff(uint32_t value)		INLINE { E::set32(section.fields.reloff, value); }

	uint32_t		nreloc() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> E::get32(section.fields.nreloc); }
	<span class="enscript-type">void</span>			set_nreloc(uint32_t value)		INLINE { E::set32(section.fields.nreloc, value); }

	uint32_t		flags() <span class="enscript-type">const</span>					INLINE { <span class="enscript-keyword">return</span> E::get32(section.fields.flags); }
	<span class="enscript-type">void</span>			set_flags(uint32_t value)		INLINE { E::set32(section.fields.flags, value); }

	uint32_t		reserved1() <span class="enscript-type">const</span>				INLINE { <span class="enscript-keyword">return</span> E::get32(section.fields.reserved1); }
	<span class="enscript-type">void</span>			set_reserved1(uint32_t value)	INLINE { E::set32(section.fields.reserved1, value); }

	uint32_t		reserved2() <span class="enscript-type">const</span>				INLINE { <span class="enscript-keyword">return</span> E::get32(section.fields.reserved2); }
	<span class="enscript-type">void</span>			set_reserved2(uint32_t value)	INLINE { E::set32(section.fields.reserved2, value); }

	<span class="enscript-type">typedef</span> typename P::E		E;
<span class="enscript-type">private</span>:
	macho_section_content&lt;P&gt;	section;
};




<span class="enscript-type">static</span> <span class="enscript-type">bool</span> debug = true;

<span class="enscript-type">bool</span> <span class="enscript-function-name">processFile</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *filename);

<span class="enscript-type">int</span> <span class="enscript-function-name">main</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *argv[]) {
    <span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 1; i &lt; argc; ++i) {
        <span class="enscript-keyword">if</span> (!processFile(argv[i])) <span class="enscript-keyword">return</span> 1;
    }
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">struct</span> imageinfo {
    uint32_t version;
    uint32_t flags;
};


<span class="enscript-comment">// Segment and section names are 16 bytes and may be un-terminated.
</span><span class="enscript-type">bool</span> <span class="enscript-function-name">segnameEquals</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *lhs, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *rhs)
{
    <span class="enscript-keyword">return</span> 0 == strncmp(lhs, rhs, 16);
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">segnameStartsWith</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *segname, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *prefix)
{
    <span class="enscript-keyword">return</span> 0 == strncmp(segname, prefix, strlen(prefix));
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">sectnameEquals</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *lhs, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *rhs)
{
    <span class="enscript-keyword">return</span> segnameEquals(lhs, rhs);
}


<span class="enscript-type">template</span> &lt;typename P&gt;
<span class="enscript-type">void</span> <span class="enscript-function-name">dosect</span>(uint8_t *start, macho_section&lt;P&gt; *sect)
{
    <span class="enscript-keyword">if</span> (debug) printf(<span class="enscript-string">&quot;section %.16s from segment %.16s\n&quot;</span>,
                      sect-&gt;sectname(), sect-&gt;segname());

    <span class="enscript-comment">// Strip S_MOD_INIT/TERM_FUNC_POINTERS. We don't want dyld to call 
</span>    <span class="enscript-comment">// our init funcs because it is too late, and we don't want anyone to 
</span>    <span class="enscript-comment">// call our term funcs ever.
</span>    <span class="enscript-keyword">if</span> (segnameStartsWith(sect-&gt;segname(), <span class="enscript-string">&quot;__DATA&quot;</span>)  &amp;&amp;  
        sectnameEquals(sect-&gt;sectname(), <span class="enscript-string">&quot;__mod_init_func&quot;</span>))
    {
        <span class="enscript-comment">// section type 0 is S_REGULAR
</span>        sect-&gt;set_flags(sect-&gt;flags() &amp; ~SECTION_TYPE);
        sect-&gt;set_sectname(<span class="enscript-string">&quot;__objc_init_func&quot;</span>);
        <span class="enscript-keyword">if</span> (debug) printf(<span class="enscript-string">&quot;disabled __mod_init_func section\n&quot;</span>);
    }
    <span class="enscript-keyword">if</span> (segnameStartsWith(sect-&gt;segname(), <span class="enscript-string">&quot;__DATA&quot;</span>)  &amp;&amp;  
        sectnameEquals(sect-&gt;sectname(), <span class="enscript-string">&quot;__mod_term_func&quot;</span>))
    {
        <span class="enscript-comment">// section type 0 is S_REGULAR
</span>        sect-&gt;set_flags(sect-&gt;flags() &amp; ~SECTION_TYPE);
        sect-&gt;set_sectname(<span class="enscript-string">&quot;__objc_term_func&quot;</span>);
        <span class="enscript-keyword">if</span> (debug) printf(<span class="enscript-string">&quot;disabled __mod_term_func section\n&quot;</span>);
    }
}

<span class="enscript-type">template</span> &lt;typename P&gt;
<span class="enscript-type">void</span> <span class="enscript-function-name">doseg</span>(uint8_t *start, macho_segment_command&lt;P&gt; *seg)
{
    <span class="enscript-keyword">if</span> (debug) printf(<span class="enscript-string">&quot;segment name: %.16s, nsects %u\n&quot;</span>,
                      seg-&gt;segname(), seg-&gt;nsects());
    macho_section&lt;P&gt; *sect = (macho_section&lt;P&gt; *)(seg + 1);
    <span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; seg-&gt;nsects(); ++i) {
        dosect(start, &amp;sect[i]);
    }
}


<span class="enscript-type">template</span>&lt;typename P&gt;
<span class="enscript-type">bool</span> <span class="enscript-function-name">parse_macho</span>(uint8_t *buffer)
{
    macho_header&lt;P&gt;* mh = (macho_header&lt;P&gt;*)buffer;
    uint8_t *cmds = (uint8_t *)(mh + 1);
    <span class="enscript-keyword">for</span> (uint32_t c = 0; c &lt; mh-&gt;ncmds(); c++) {
        macho_load_command&lt;P&gt;* cmd = (macho_load_command&lt;P&gt;*)cmds;
        cmds += cmd-&gt;cmdsize();
        <span class="enscript-keyword">if</span> (cmd-&gt;cmd() == LC_SEGMENT  ||  cmd-&gt;cmd() == LC_SEGMENT_64) {
            doseg(buffer, (macho_segment_command&lt;P&gt;*)cmd);
        }
    }

    <span class="enscript-keyword">return</span> true;
}


<span class="enscript-type">bool</span> <span class="enscript-function-name">parse_macho</span>(uint8_t *buffer)
{
    uint32_t magic = *(uint32_t *)buffer;

    <span class="enscript-keyword">switch</span> (magic) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">MH_MAGIC_64</span>:
        <span class="enscript-keyword">return</span> parse_macho&lt;Pointer64&lt;CurrentEndian&gt;&gt;(buffer);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">MH_MAGIC</span>:
        <span class="enscript-keyword">return</span> parse_macho&lt;Pointer32&lt;CurrentEndian&gt;&gt;(buffer);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">MH_CIGAM_64</span>:
        <span class="enscript-keyword">return</span> parse_macho&lt;Pointer64&lt;OtherEndian&gt;&gt;(buffer);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">MH_CIGAM</span>:
        <span class="enscript-keyword">return</span> parse_macho&lt;Pointer32&lt;OtherEndian&gt;&gt;(buffer);
    <span class="enscript-reference">default</span>:
        printf(<span class="enscript-string">&quot;file is not mach-o (magic %x)\n&quot;</span>, magic);
        <span class="enscript-keyword">return</span> false;
    }
}


<span class="enscript-type">bool</span> <span class="enscript-function-name">parse_fat</span>(uint8_t *buffer, size_t size)
{
    uint32_t magic;

    <span class="enscript-keyword">if</span> (size &lt; <span class="enscript-keyword">sizeof</span>(magic)) {
        printf(<span class="enscript-string">&quot;file is too small\n&quot;</span>);
        <span class="enscript-keyword">return</span> false;
    }

    magic = *(uint32_t *)buffer;
    <span class="enscript-keyword">if</span> (magic != FAT_MAGIC &amp;&amp; magic != FAT_CIGAM) {
        <span class="enscript-comment">/* Not a fat file */</span>
        <span class="enscript-keyword">return</span> parse_macho(buffer);
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-type">struct</span> fat_header *fh;
        uint32_t fat_magic, fat_nfat_arch;
        <span class="enscript-type">struct</span> fat_arch *archs;
        
        <span class="enscript-keyword">if</span> (size &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> fat_header)) {
            printf(<span class="enscript-string">&quot;file is too small\n&quot;</span>);
            <span class="enscript-keyword">return</span> false;
        }

        fh = (<span class="enscript-type">struct</span> fat_header *)buffer;
        fat_magic = OSSwapBigToHostInt32(fh-&gt;magic);
        fat_nfat_arch = OSSwapBigToHostInt32(fh-&gt;nfat_arch);

        size_t fat_arch_size;
        <span class="enscript-comment">// fat_nfat_arch * sizeof(struct fat_arch) + sizeof(struct fat_header)
</span>        <span class="enscript-keyword">if</span> (os_mul_and_add_overflow(fat_nfat_arch, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> fat_arch),
                                    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> fat_header), &amp;fat_arch_size))
        {
            printf(<span class="enscript-string">&quot;too many fat archs\n&quot;</span>);
            <span class="enscript-keyword">return</span> false;
        }
        <span class="enscript-keyword">if</span> (size &lt; fat_arch_size) {
            printf(<span class="enscript-string">&quot;file is too small\n&quot;</span>);
            <span class="enscript-keyword">return</span> false;
        }

        archs = (<span class="enscript-type">struct</span> fat_arch *)(buffer + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> fat_header));

        <span class="enscript-comment">/* Special case hidden CPU_TYPE_ARM64 */</span>
        size_t fat_arch_plus_one_size;
        <span class="enscript-keyword">if</span> (os_add_overflow(fat_arch_size, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> fat_arch),
                            &amp;fat_arch_plus_one_size))
        {
            printf(<span class="enscript-string">&quot;too many fat archs\n&quot;</span>);
            <span class="enscript-keyword">return</span> false;
        }
        <span class="enscript-keyword">if</span> (size &gt;= fat_arch_plus_one_size) {
            <span class="enscript-keyword">if</span> (fat_nfat_arch &gt; 0
                &amp;&amp; OSSwapBigToHostInt32(archs[fat_nfat_arch].cputype) == CPU_TYPE_ARM64) {
                fat_nfat_arch++;
            }
        }
        <span class="enscript-comment">/* End special case hidden CPU_TYPE_ARM64 */</span>

        <span class="enscript-keyword">if</span> (debug) printf(<span class="enscript-string">&quot;%d fat architectures\n&quot;</span>, 
                          fat_nfat_arch);

        <span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; fat_nfat_arch; i++) {
            uint32_t arch_cputype = OSSwapBigToHostInt32(archs[i].cputype);
            uint32_t arch_cpusubtype = OSSwapBigToHostInt32(archs[i].cpusubtype);
            uint32_t arch_offset = OSSwapBigToHostInt32(archs[i].offset);
            uint32_t arch_size = OSSwapBigToHostInt32(archs[i].size);

            <span class="enscript-keyword">if</span> (debug) printf(<span class="enscript-string">&quot;cputype %d cpusubtype %d\n&quot;</span>, 
                              arch_cputype, arch_cpusubtype);

            <span class="enscript-comment">/* Check that slice data is after all fat headers and archs */</span>
            <span class="enscript-keyword">if</span> (arch_offset &lt; fat_arch_size) {
                printf(<span class="enscript-string">&quot;file is badly formed\n&quot;</span>);
                <span class="enscript-keyword">return</span> false;
            }

            <span class="enscript-comment">/* Check that the slice ends before the file does */</span>
            <span class="enscript-keyword">if</span> (arch_offset &gt; size) {
                printf(<span class="enscript-string">&quot;file is badly formed\n&quot;</span>);
                <span class="enscript-keyword">return</span> false;
            }

            <span class="enscript-keyword">if</span> (arch_size &gt; size) {
                printf(<span class="enscript-string">&quot;file is badly formed\n&quot;</span>);
                <span class="enscript-keyword">return</span> false;
            }

            <span class="enscript-keyword">if</span> (arch_offset &gt; (size - arch_size)) {
                printf(<span class="enscript-string">&quot;file is badly formed\n&quot;</span>);
                <span class="enscript-keyword">return</span> false;
            }

            <span class="enscript-type">bool</span> ok = parse_macho(buffer + arch_offset);
            <span class="enscript-keyword">if</span> (!ok) <span class="enscript-keyword">return</span> false;
        }
        <span class="enscript-keyword">return</span> true;
    }
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">processFile</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *filename)
{
    <span class="enscript-keyword">if</span> (debug) printf(<span class="enscript-string">&quot;file %s\n&quot;</span>, filename);
    <span class="enscript-type">int</span> fd = open(filename, O_RDWR);
    <span class="enscript-keyword">if</span> (fd &lt; 0) {
        printf(<span class="enscript-string">&quot;open %s: %s\n&quot;</span>, filename, strerror(errno));
        <span class="enscript-keyword">return</span> false;
    }
    
    <span class="enscript-type">struct</span> stat st;
    <span class="enscript-keyword">if</span> (fstat(fd, &amp;st) &lt; 0) {
        printf(<span class="enscript-string">&quot;fstat %s: %s\n&quot;</span>, filename, strerror(errno));
        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-type">void</span> *buffer = mmap(NULL, (size_t)st.st_size, PROT_READ|PROT_WRITE, 
                        MAP_FILE|MAP_SHARED, fd, 0);
    <span class="enscript-keyword">if</span> (buffer == MAP_FAILED) {
        printf(<span class="enscript-string">&quot;mmap %s: %s\n&quot;</span>, filename, strerror(errno));
        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-type">bool</span> result = parse_fat((uint8_t *)buffer, (size_t)st.st_size);
    munmap(buffer, (size_t)st.st_size);
    close(fd);
    <span class="enscript-keyword">return</span> result;
}
</pre>
<hr />
</body></html>